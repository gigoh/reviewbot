import { loadConfig } from './config';
import { GitLabClient } from './services/gitlab';
import { AIReviewer } from './services/reviewer';
import { parseMergeRequestUrl } from './utils/parser';
import { Logger } from './utils/logger';
import { getReviewMetadata } from './utils/network';
import { ReviewResult } from './types';

export interface ReviewOptions {
  mrUrl: string;
  postComment?: boolean;
  outputFormat?: 'text' | 'json';
}

/**
 * Main function to review a GitLab merge request
 */
export async function reviewMergeRequest(
  options: ReviewOptions
): Promise<ReviewResult> {
  try {
    // Load configuration
    const config = loadConfig();

    // Parse the MR URL
    const { projectPath, mrIid } = parseMergeRequestUrl(options.mrUrl);
    Logger.info(`Reviewing MR #${mrIid} in project: ${projectPath}`);

    // Initialize clients
    const gitlabClient = new GitLabClient(config);
    const aiReviewer = new AIReviewer(config);

    // Fetch MR information
    Logger.info('Fetching merge request details...');
    const mrInfo = await gitlabClient.getMergeRequest(projectPath, mrIid);

    // Fetch MR changes
    Logger.info('Fetching code changes...');
    const changes = await gitlabClient.getMergeRequestChanges(projectPath, mrIid);

    Logger.info(`Found ${changes.length} changed file(s)`);

    // Perform AI review
    const reviewResult = await aiReviewer.reviewChanges(mrInfo, changes);

    // Post comments if requested
    if (options.postComment) {
      Logger.info('Posting review comments...');

      // Post summary and overall assessment as a general comment
      const summaryComment = formatSummaryComment(reviewResult);
      await gitlabClient.postComment(projectPath, mrIid, summaryComment);

      // Post each detailed comment as a line-specific discussion
      if (reviewResult.comments.length > 0) {
        Logger.info(`Posting ${reviewResult.comments.length} line-specific comment(s)...`);

        for (const item of reviewResult.comments) {
          if (item.lineNumber) {
            const lineComment = formatLineComment(item);
            await gitlabClient.postLineComment(
              projectPath,
              mrIid,
              item.filePath,
              item.lineNumber,
              lineComment,
              mrInfo.diffRefs
            );
          } else {
            // If no line number, post as general comment with file reference
            const fileComment = `**${item.filePath}**\n\n${formatLineComment(item)}`;
            await gitlabClient.postComment(projectPath, mrIid, fileComment);
          }
        }
      }

      Logger.success('All review comments posted successfully');
    }

    return reviewResult;
  } catch (error: any) {
    Logger.error('Review failed', error);
    throw error;
  }
}

/**
 * Format summary and overall assessment as a general comment
 */
function formatSummaryComment(review: ReviewResult): string {
  let comment = '## ü§ñ AI Code Review Summary\n\n';

  comment += `### Summary\n${review.summary}\n\n`;

  comment += `### Overall Assessment\n${review.overallAssessment}\n\n`;

  if (review.comments.length > 0) {
    comment += `---\n\n`;
    comment += `üìù **${review.comments.length} detailed comment(s)** have been posted on specific lines in the changed files.\n\n`;
  }

  comment += '---\n';
  comment += `*Review generated by AI-powered reviewbot*\n\n`;
  comment += `_${getReviewMetadata()}_\n`;

  return comment;
}

/**
 * Format a single review comment for a specific line
 */
function formatLineComment(item: ReviewResult['comments'][0]): string {
  const emoji = getSeverityEmoji(item.severity);

  let comment = `${emoji} **${item.severity.toUpperCase()}**\n\n`;
  comment += `${item.comment}`;

  return comment;
}

/**
 * Get emoji for severity level
 */
function getSeverityEmoji(severity: string): string {
  const emojiMap: Record<string, string> = {
    critical: 'üî¥',
    warning: 'üü°',
    suggestion: 'üí°',
    info: '‚ÑπÔ∏è',
  };
  return emojiMap[severity] || '‚ÑπÔ∏è';
}
